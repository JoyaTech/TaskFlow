import 'package:flutter/material.dart';
import 'dart:math' as math;

/// MindFlow Custom Graphics System
/// ADHD-Focused, Hebrew-First Task Management Graphics
/// - Calming Blue (#6B73FF) and Professional Purple (#9C27B0)
/// - Cognitive load reduction through sensory-friendly design
/// - RTL Hebrew support with cultural sensitivity
/// - Neurodivergent-first accessibility features

class MindFlowGraphics {
  // MindFlow Brand Color Palette
  static const Color primaryBlue = Color(0xFF6B73FF);     // Calming Blue
  static const Color professionalPurple = Color(0xFF9C27B0); // Professional Purple
  static const Color calmGray = Color(0xFF8E8E93);        // Gentle Gray
  static const Color successGreen = Color(0xFF4CAF50);    // Achievement Green
  static const Color warningAmber = Color(0xFFFFC107);    // Gentle Warning
  static const Color softBackground = Color(0xFFF8F9FA);  // ADHD-friendly background
  
  /// 1. ONBOARDING ILLUSTRATIONS
  
  // Illustration 1: "Smart Voice Input" - Wave becoming organized
  static Widget voiceWaveIllustration({double size = 200}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: VoiceWavePainter(),
      ),
    );
  }
  
  // Illustration 2: "Task Breakdown" - Complex shape breaking into simple ones
  static Widget taskBreakdownIllustration({double size = 200}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: TaskBreakdownPainter(),
      ),
    );
  }
  
  // Illustration 3: "Focus & Flow" - Chaotic lines becoming one flowing line
  static Widget focusFlowIllustration({double size = 200}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: FocusFlowPainter(),
      ),
    );
  }
  
  /// 2. EMPTY STATES
  
  // Empty State 1: "All Done!" - Calm waves
  static Widget allDoneIllustration({double size = 120}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: CalmWavesPainter(),
      ),
    );
  }
  
  // Empty State 2: "Empty Mind Box"
  static Widget emptyMindIllustration({double size = 120}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: EmptyMindPainter(),
      ),
    );
  }
  
  /// 3. CELEBRATION ICONS
  
  // Celebration 1: Minimalist star with radiating lines
  static Widget celebrationStar({double size = 60}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: CelebrationStarPainter(),
      ),
    );
  }
  
  // Celebration 2: Check mark becoming a leaf/wave
  static Widget celebrationCheck({double size = 60}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: CelebrationCheckPainter(),
      ),
    );
  }
  
  // Celebration 3: Expanding circle
  static Widget celebrationCircle({double size = 60, double progress = 1.0}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: CelebrationCirclePainter(progress: progress),
      ),
    );
  }
  
  /// 4. CUSTOM CATEGORY ICONS
  
  // Task icon: Circle with check
  static Widget taskIcon({double size = 24, Color? color}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: TaskIconPainter(color: color ?? Colors.black87),
      ),
    );
  }
  
  // Note icon: Square with wavy line
  static Widget noteIcon({double size = 24, Color? color}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: NoteIconPainter(color: color ?? Colors.black87),
      ),
    );
  }
  
  // Event icon: Minimalist calendar
  static Widget eventIcon({double size = 24, Color? color}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: EventIconPainter(color: color ?? Colors.black87),
      ),
    );
  }
  
  // Priority icon: Minimalist star
  static Widget priorityIcon({double size = 24, Color? color}) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: PriorityIconPainter(color: color ?? Colors.black87),
      ),
    );
  }

  /// 5. VOICE INTERFACE SYSTEM - ADHD Optimized
  
  // Voice microphone with three states: idle, listening, processing
  static Widget voiceMicrophone({
    double size = 60,
    VoiceState state = VoiceState.idle,
    bool isAnimating = false,
  }) {
    return Container(
      width: size,
      height: size,
      child: CustomPaint(
        painter: VoiceMicrophonePainter(
          state: state,
          isAnimating: isAnimating,
        ),
      ),
    );
  }
  
  // Audio wave visualizer for voice input
  static Widget audioWaveVisualizer({
    double size = 200,
    List<double> waveAmplitudes = const [0.3, 0.7, 0.5, 0.9, 0.4],
    bool isActive = false,
  }) {
    return Container(
      width: size,
      height: size * 0.4,
      child: CustomPaint(
        painter: AudioWavePainter(
          amplitudes: waveAmplitudes,
          isActive: isActive,
        ),
      ),
    );
  }
  
  // Hebrew voice command tutorial overlay
  static Widget hebrewVoiceTutorial({
    required String hebrewText,
    required String englishHint,
    double size = 300,
  }) {
    return Container(
      width: size,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: softBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: primaryBlue.withOpacity(0.3)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            hebrewText,
            style: const TextStyle(
              fontFamily: 'NotoSansHebrew',
              fontSize: 18,
              fontWeight: FontWeight.w500,
              color: Colors.black87,
            ),
            textDirection: TextDirection.rtl,
          ),
          const SizedBox(height: 8),
          Text(
            englishHint,
            style: TextStyle(
              fontSize: 14,
              color: calmGray,
              fontStyle: FontStyle.italic,
            ),
          ),
        ],
      ),
    );
  }
  
  /// 6. ADHD-SPECIFIC UI COMPONENTS
  
  // Calming task card with subtle shadows and ADHD-friendly design
  static Widget adhdTaskCard({
    required String title,
    String? subtitle,
    double width = 300,
    double height = 120,
    bool isCompleted = false,
    VoidCallback? onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: width,
        height: height,
        margin: const EdgeInsets.symmetric(vertical: 6),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.08),
              blurRadius: 12,
              offset: const Offset(0, 2),
            ),
          ],
          border: isCompleted
              ? Border.all(color: successGreen.withOpacity(0.5), width: 2)
              : Border.all(color: Colors.transparent),
        ),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Task status indicator
              Container(
                width: 12,
                height: 12,
                decoration: BoxDecoration(
                  color: isCompleted ? successGreen : primaryBlue,
                  borderRadius: BorderRadius.circular(6),
                ),
              ),
              const SizedBox(width: 12),
              // Task content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      title,
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: isCompleted ? calmGray : Colors.black87,
                        decoration: isCompleted ? TextDecoration.lineThrough : null,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    if (subtitle != null) ...[
                      const SizedBox(height: 4),
                      Text(
                        subtitle,
                        style: TextStyle(
                          fontSize: 14,
                          color: calmGray,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  // Pomodoro timer with ADHD-friendly design
  static Widget pomodoroTimer({
    required Duration remainingTime,
    required Duration totalTime,
    bool isPaused = false,
    VoidCallback? onPlayPause,
    VoidCallback? onStop,
    double size = 200,
  }) {
    final progress = 1.0 - (remainingTime.inSeconds / totalTime.inSeconds);
    final minutes = remainingTime.inMinutes;
    final seconds = remainingTime.inSeconds % 60;
    
    return Container(
      width: size,
      height: size,
      child: Stack(
        alignment: Alignment.center,
        children: [
          // Progress circle
          CustomPaint(
            size: Size(size, size),
            painter: PomodoroProgressPainter(
              progress: progress,
              isPaused: isPaused,
            ),
          ),
          // Time display
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}',
                style: const TextStyle(
                  fontSize: 32,
                  fontWeight: FontWeight.w700,
                  color: Colors.black87,
                ),
              ),
              const SizedBox(height: 12),
              // Control buttons
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    onPressed: onPlayPause,
                    icon: Icon(
                      isPaused ? Icons.play_arrow : Icons.pause,
                      color: primaryBlue,
                      size: 28,
                    ),
                  ),
                  const SizedBox(width: 8),
                  IconButton(
                    onPressed: onStop,
                    icon: Icon(
                      Icons.stop,
                      color: calmGray,
                      size: 24,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ],
      ),
    );
  }
  
  // Gentle break reminder with calming animation
  static Widget gentleBreakReminder({
    double size = 150,
    String message = "זמן להפסקה קטנה", // "Time for a small break"
  }) {
    return Container(
      width: size,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: size * 0.6,
            height: size * 0.6,
            child: CustomPaint(
              painter: BreakReminderPainter(),
            ),
          ),
          const SizedBox(height: 12),
          Text(
            message,
            style: const TextStyle(
              fontFamily: 'NotoSansHebrew',
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: Colors.black87,
            ),
            textDirection: TextDirection.rtl,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
  
  /// 7. GAMIFICATION SYSTEM
  
  // Achievement badge with 5-tier system
  static Widget achievementBadge({
    required AchievementType type,
    required int tier, // 1-5
    double size = 80,
    bool isUnlocked = false,
  }) {
    return Container(
      width: size,
      height: size,
      child: Stack(
        alignment: Alignment.center,
        children: [
          // Badge background
          CustomPaint(
            size: Size(size, size),
            painter: AchievementBadgePainter(
              type: type,
              tier: tier,
              isUnlocked: isUnlocked,
            ),
          ),
          // Lock overlay for locked badges
          if (!isUnlocked)
            Container(
              width: size * 0.3,
              height: size * 0.3,
              decoration: BoxDecoration(
                color: calmGray,
                borderRadius: BorderRadius.circular(size * 0.15),
              ),
              child: Icon(
                Icons.lock,
                color: Colors.white,
                size: size * 0.15,
              ),
            ),
        ],
      ),
    );
  }
  
  // Animated progress bar with Hebrew labels
  static Widget hebrewProgressBar({
    required double progress, // 0.0 to 1.0
    required String label,
    double width = 200,
    double height = 8,
    Color? progressColor,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.end, // RTL alignment
      children: [
        Text(
          label,
          style: const TextStyle(
            fontFamily: 'NotoSansHebrew',
            fontSize: 14,
            fontWeight: FontWeight.w500,
            color: Colors.black87,
          ),
          textDirection: TextDirection.rtl,
        ),
        const SizedBox(height: 6),
        Container(
          width: width,
          height: height,
          decoration: BoxDecoration(
            color: Colors.grey[200],
            borderRadius: BorderRadius.circular(height / 2),
          ),
          child: Stack(
            children: [
              Container(
                width: width * progress.clamp(0.0, 1.0),
                height: height,
                decoration: BoxDecoration(
                  color: progressColor ?? primaryBlue,
                  borderRadius: BorderRadius.circular(height / 2),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
  
  // Level indicator with star system
  static Widget levelIndicator({
    required int currentLevel, // 1-5
    double size = 24,
  }) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(5, (index) {
        final isFilled = index < currentLevel;
        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 2),
          child: Icon(
            isFilled ? Icons.star : Icons.star_border,
            color: isFilled ? warningAmber : calmGray,
            size: size,
          ),
        );
      }),
    );
  }
}

/// CUSTOM PAINTERS IMPLEMENTATION

class VoiceWavePainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = FocusFlowGraphics.primaryTint.withOpacity(0.8)
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final path = Path();
    
    // Chaotic wave on the left
    path.moveTo(20, size.height * 0.5);
    for (int i = 0; i < 5; i++) {
      double x = 20 + (i * 20);
      double y = size.height * 0.5 + (i % 2 == 0 ? -30 : 30) * (1 - i * 0.1);
      path.lineTo(x, y);
    }
    
    // Transition to organized line
    path.lineTo(size.width * 0.7, size.height * 0.5);
    path.lineTo(size.width - 20, size.height * 0.5);
    
    canvas.drawPath(path, paint);
    
    // Add subtle task box at the end
    final boxPaint = Paint()
      ..color = FocusFlowGraphics.neutralGray.withOpacity(0.3)
      ..style = PaintingStyle.fill;
    
    canvas.drawRRect(
      RRect.fromRectAndRadius(
        Rect.fromLTWH(size.width - 40, size.height * 0.4, 30, 20),
        Radius.circular(4),
      ),
      boxPaint,
    );
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class TaskBreakdownPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = MindFlowGraphics.professionalPurple.withOpacity(0.8)
      ..style = PaintingStyle.fill;
    
    // Large complex shape on the left
    final largePath = Path();
    largePath.addRRect(RRect.fromRectAndRadius(
      Rect.fromLTWH(20, size.height * 0.2, 80, 80),
      Radius.circular(20),
    ));
    canvas.drawPath(largePath, paint);
    
    // Arrow indicating transformation
    final arrowPaint = Paint()
      ..color = MindFlowGraphics.calmGray
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    canvas.drawLine(
      Offset(110, size.height * 0.5),
      Offset(140, size.height * 0.5),
      arrowPaint,
    );
    
    // Small simple shapes on the right
    final smallPaint = Paint()
      ..color = MindFlowGraphics.primaryBlue.withOpacity(0.6)
      ..style = PaintingStyle.fill;
    
    // Three small rectangles
    for (int i = 0; i < 3; i++) {
      canvas.drawRRect(
        RRect.fromRectAndRadius(
          Rect.fromLTWH(
            160,
            size.height * 0.3 + (i * 25),
            20,
            20,
          ),
          Radius.circular(4),
        ),
        smallPaint,
      );
    }
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class FocusFlowPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final chaosPaint = Paint()
      ..color = FocusFlowGraphics.neutralGray.withOpacity(0.4)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    // Chaotic lines on the left
    for (int i = 0; i < 8; i++) {
      canvas.drawLine(
        Offset(20 + (i * 10), 20 + (i * 5)),
        Offset(40 + (i * 8), size.height - 20 - (i * 8)),
        chaosPaint,
      );
    }
    
    // Single flowing line on the right
    final flowPaint = Paint()
      ..color = FocusFlowGraphics.primaryTint
      ..strokeWidth = 4
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final flowPath = Path();
    flowPath.moveTo(size.width * 0.6, size.height * 0.3);
    flowPath.quadraticBezierTo(
      size.width * 0.8,
      size.height * 0.5,
      size.width - 20,
      size.height * 0.7,
    );
    
    canvas.drawPath(flowPath, flowPaint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class CalmWavesPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = FocusFlowGraphics.secondaryTint.withOpacity(0.6)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    // Draw multiple gentle waves
    for (int i = 0; i < 3; i++) {
      final path = Path();
      double yOffset = size.height * 0.3 + (i * 20);
      
      path.moveTo(10, yOffset);
      for (double x = 10; x < size.width - 10; x += 20) {
        path.quadraticBezierTo(
          x + 10,
          yOffset + 8,
          x + 20,
          yOffset,
        );
      }
      
      canvas.drawPath(path, paint);
    }
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class EmptyMindPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = FocusFlowGraphics.neutralGray.withOpacity(0.7)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    // Head outline
    final headPath = Path();
    headPath.addOval(Rect.fromCenter(
      center: Offset(size.width * 0.5, size.height * 0.4),
      width: size.width * 0.6,
      height: size.height * 0.6,
    ));
    
    canvas.drawPath(headPath, paint);
    
    // Flowing lines inside representing clear thoughts
    final flowPaint = Paint()
      ..color = FocusFlowGraphics.primaryTint.withOpacity(0.4)
      ..strokeWidth = 1
      ..style = PaintingStyle.stroke;
    
    final innerPath = Path();
    innerPath.moveTo(size.width * 0.3, size.height * 0.4);
    innerPath.quadraticBezierTo(
      size.width * 0.5,
      size.height * 0.3,
      size.width * 0.7,
      size.height * 0.4,
    );
    
    canvas.drawPath(innerPath, flowPaint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class CelebrationStarPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = FocusFlowGraphics.primaryTint
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final center = Offset(size.width / 2, size.height / 2);
    
    // Star rays
    for (int i = 0; i < 8; i++) {
      double angle = (i * 45) * (3.14159 / 180);
      double length = i % 2 == 0 ? 20 : 12;
      
      canvas.drawLine(
        center,
        Offset(
          center.dx + length * cos(angle),
          center.dy + length * sin(angle),
        ),
        paint,
      );
    }
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class CelebrationCheckPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = FocusFlowGraphics.secondaryTint
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final path = Path();
    path.moveTo(size.width * 0.2, size.height * 0.5);
    path.lineTo(size.width * 0.45, size.height * 0.7);
    path.quadraticBezierTo(
      size.width * 0.6,
      size.height * 0.4,
      size.width * 0.8,
      size.height * 0.3,
    );
    
    canvas.drawPath(path, paint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class CelebrationCirclePainter extends CustomPainter {
  final double progress;
  
  CelebrationCirclePainter({required this.progress});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = FocusFlowGraphics.primaryTint.withOpacity(0.6 * (1 - progress))
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      (size.width / 2) * progress,
      paint,
    );
  }
  
  @override
  bool shouldRepaint(CelebrationCirclePainter oldDelegate) {
    return oldDelegate.progress != progress;
  }
}

class TaskIconPainter extends CustomPainter {
  final Color color;
  
  TaskIconPainter({required this.color});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    // Circle
    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      size.width / 2 - 2,
      paint,
    );
    
    // Check mark
    final checkPaint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final checkPath = Path();
    checkPath.moveTo(size.width * 0.3, size.height * 0.5);
    checkPath.lineTo(size.width * 0.45, size.height * 0.65);
    checkPath.lineTo(size.width * 0.7, size.height * 0.35);
    
    canvas.drawPath(checkPath, checkPaint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class NoteIconPainter extends CustomPainter {
  final Color color;
  
  NoteIconPainter({required this.color});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    // Square
    canvas.drawRRect(
      RRect.fromRectAndRadius(
        Rect.fromLTWH(2, 2, size.width - 4, size.height - 4),
        Radius.circular(3),
      ),
      paint,
    );
    
    // Wavy line inside
    final wavyPaint = Paint()
      ..color = color
      ..strokeWidth = 1
      ..style = PaintingStyle.stroke;
    
    final wavyPath = Path();
    wavyPath.moveTo(size.width * 0.2, size.height * 0.5);
    wavyPath.quadraticBezierTo(
      size.width * 0.4,
      size.height * 0.4,
      size.width * 0.6,
      size.height * 0.5,
    );
    wavyPath.quadraticBezierTo(
      size.width * 0.8,
      size.height * 0.6,
      size.width * 0.8,
      size.height * 0.5,
    );
    
    canvas.drawPath(wavyPath, wavyPaint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class EventIconPainter extends CustomPainter {
  final Color color;
  
  EventIconPainter({required this.color});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    // Calendar base
    canvas.drawRRect(
      RRect.fromRectAndRadius(
        Rect.fromLTWH(2, 4, size.width - 4, size.height - 6),
        Radius.circular(2),
      ),
      paint,
    );
    
    // Calendar rings
    canvas.drawLine(
      Offset(size.width * 0.3, 2),
      Offset(size.width * 0.3, 8),
      paint,
    );
    
    canvas.drawLine(
      Offset(size.width * 0.7, 2),
      Offset(size.width * 0.7, 8),
      paint,
    );
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class PriorityIconPainter extends CustomPainter {
  final Color color;
  
  PriorityIconPainter({required this.color});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.5
      ..style = PaintingStyle.stroke
      ..strokeJoin = StrokeJoin.round;
    
    final starPath = Path();
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 3;
    
    // Simple 5-pointed star outline
    for (int i = 0; i < 5; i++) {
      double angle = (i * 72 - 90) * (3.14159 / 180);
      double x = center.dx + radius * cos(angle);
      double y = center.dy + radius * sin(angle);
      
      if (i == 0) {
        starPath.moveTo(x, y);
      } else {
        starPath.lineTo(x, y);
      }
    }
    starPath.close();
    
    canvas.drawPath(starPath, paint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

/// ENUMS FOR MINDFLOW GRAPHICS

enum VoiceState {
  idle,
  listening,
  processing,
}

enum AchievementType {
  firstTask,     // "First Task Completed"
  weekStreak,    // "Week Streak Master" 
  focusChampion, // "Focus Champion"
  voiceCommander,// "Voice Commander"
  productivityGuru, // "Productivity Guru"
}

/// NEW PAINTER CLASSES FOR MINDFLOW

class VoiceMicrophonePainter extends CustomPainter {
  final VoiceState state;
  final bool isAnimating;
  
  VoiceMicrophonePainter({
    required this.state,
    required this.isAnimating,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 3;
    
    // Base microphone shape
    final micPaint = Paint()
      ..color = _getMicColor()
      ..style = PaintingStyle.fill;
    
    // Draw microphone body
    canvas.drawRRect(
      RRect.fromRectAndRadius(
        Rect.fromCenter(
          center: center,
          width: radius,
          height: radius * 1.5,
        ),
        Radius.circular(radius / 2),
      ),
      micPaint,
    );
    
    // Draw microphone stand
    final standPaint = Paint()
      ..color = _getMicColor()
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke;
    
    canvas.drawLine(
      Offset(center.dx, center.dy + radius * 0.75),
      Offset(center.dx, center.dy + radius * 1.2),
      standPaint,
    );
    
    // Draw animation rings for listening/processing states
    if (state != VoiceState.idle && isAnimating) {
      _drawAnimationRings(canvas, center, radius);
    }
  }
  
  Color _getMicColor() {
    switch (state) {
      case VoiceState.idle:
        return MindFlowGraphics.calmGray;
      case VoiceState.listening:
        return MindFlowGraphics.primaryBlue;
      case VoiceState.processing:
        return MindFlowGraphics.professionalPurple;
    }
  }
  
  void _drawAnimationRings(Canvas canvas, Offset center, double radius) {
    final ringPaint = Paint()
      ..color = _getMicColor().withOpacity(0.3)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    // Draw concentric rings
    for (int i = 1; i <= 3; i++) {
      canvas.drawCircle(
        center,
        radius + (i * 8),
        ringPaint,
      );
    }
  }
  
  @override
  bool shouldRepaint(VoiceMicrophonePainter oldDelegate) {
    return oldDelegate.state != state || oldDelegate.isAnimating != isAnimating;
  }
}

class AudioWavePainter extends CustomPainter {
  final List<double> amplitudes;
  final bool isActive;
  
  AudioWavePainter({
    required this.amplitudes,
    required this.isActive,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = isActive ? MindFlowGraphics.primaryBlue : MindFlowGraphics.calmGray
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final barWidth = size.width / amplitudes.length;
    final centerY = size.height / 2;
    
    for (int i = 0; i < amplitudes.length; i++) {
      final barHeight = size.height * amplitudes[i] * (isActive ? 1.0 : 0.3);
      final x = i * barWidth + barWidth / 2;
      
      canvas.drawLine(
        Offset(x, centerY - barHeight / 2),
        Offset(x, centerY + barHeight / 2),
        paint,
      );
    }
  }
  
  @override
  bool shouldRepaint(AudioWavePainter oldDelegate) {
    return oldDelegate.isActive != isActive ||
           !_listEquals(oldDelegate.amplitudes, amplitudes);
  }
  
  bool _listEquals(List<double> a, List<double> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}

class PomodoroProgressPainter extends CustomPainter {
  final double progress;
  final bool isPaused;
  
  PomodoroProgressPainter({
    required this.progress,
    required this.isPaused,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2 - 8;
    
    // Background circle
    final backgroundPaint = Paint()
      ..color = Colors.grey[200]!
      ..strokeWidth = 8
      ..style = PaintingStyle.stroke;
    
    canvas.drawCircle(center, radius, backgroundPaint);
    
    // Progress arc
    final progressPaint = Paint()
      ..color = isPaused ? MindFlowGraphics.warningAmber : MindFlowGraphics.primaryBlue
      ..strokeWidth = 8
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final sweepAngle = 2 * math.pi * progress;
    
    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      -math.pi / 2, // Start from top
      sweepAngle,
      false,
      progressPaint,
    );
  }
  
  @override
  bool shouldRepaint(PomodoroProgressPainter oldDelegate) {
    return oldDelegate.progress != progress || oldDelegate.isPaused != isPaused;
  }
}

class BreakReminderPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    
    // Draw gentle breathing circle animation
    final breathePaint = Paint()
      ..color = MindFlowGraphics.successGreen.withOpacity(0.6)
      ..style = PaintingStyle.fill;
    
    canvas.drawCircle(center, size.width / 3, breathePaint);
    
    // Draw soft pulse rings
    for (int i = 1; i <= 2; i++) {
      final ringPaint = Paint()
        ..color = MindFlowGraphics.successGreen.withOpacity(0.3 / i)
        ..strokeWidth = 2
        ..style = PaintingStyle.stroke;
      
      canvas.drawCircle(center, (size.width / 3) + (i * 12), ringPaint);
    }
    
    // Draw zen leaf in center
    final leafPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;
    
    final leafPath = Path();
    leafPath.moveTo(center.dx, center.dy - 8);
    leafPath.quadraticBezierTo(
      center.dx + 6, center.dy - 4,
      center.dx + 8, center.dy + 2,
    );
    leafPath.quadraticBezierTo(
      center.dx + 4, center.dy + 6,
      center.dx, center.dy + 8,
    );
    leafPath.quadraticBezierTo(
      center.dx - 4, center.dy + 6,
      center.dx - 8, center.dy + 2,
    );
    leafPath.quadraticBezierTo(
      center.dx - 6, center.dy - 4,
      center.dx, center.dy - 8,
    );
    leafPath.close();
    
    canvas.drawPath(leafPath, leafPaint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class AchievementBadgePainter extends CustomPainter {
  final AchievementType type;
  final int tier;
  final bool isUnlocked;
  
  AchievementBadgePainter({
    required this.type,
    required this.tier,
    required this.isUnlocked,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2 - 4;
    
    // Badge background
    final bgPaint = Paint()
      ..color = isUnlocked ? _getBadgeColor() : MindFlowGraphics.calmGray.withOpacity(0.3)
      ..style = PaintingStyle.fill;
    
    canvas.drawCircle(center, radius, bgPaint);
    
    // Badge border with tier indication
    final borderPaint = Paint()
      ..color = isUnlocked ? _getTierColor() : MindFlowGraphics.calmGray
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke;
    
    canvas.drawCircle(center, radius - 2, borderPaint);
    
    if (isUnlocked) {
      _drawBadgeIcon(canvas, center, radius * 0.6);
    }
  }
  
  Color _getBadgeColor() {
    switch (type) {
      case AchievementType.firstTask:
        return MindFlowGraphics.successGreen.withOpacity(0.2);
      case AchievementType.weekStreak:
        return MindFlowGraphics.primaryBlue.withOpacity(0.2);
      case AchievementType.focusChampion:
        return MindFlowGraphics.professionalPurple.withOpacity(0.2);
      case AchievementType.voiceCommander:
        return MindFlowGraphics.warningAmber.withOpacity(0.2);
      case AchievementType.productivityGuru:
        return MindFlowGraphics.primaryBlue.withOpacity(0.3);
    }
  }
  
  Color _getTierColor() {
    switch (tier) {
      case 1: return MindFlowGraphics.calmGray;
      case 2: return MindFlowGraphics.successGreen;
      case 3: return MindFlowGraphics.primaryBlue;
      case 4: return MindFlowGraphics.professionalPurple;
      case 5: return MindFlowGraphics.warningAmber;
      default: return MindFlowGraphics.calmGray;
    }
  }
  
  void _drawBadgeIcon(Canvas canvas, Offset center, double iconSize) {
    final iconPaint = Paint()
      ..color = _getTierColor()
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    switch (type) {
      case AchievementType.firstTask:
        // Draw checkmark
        final checkPath = Path();
        checkPath.moveTo(center.dx - iconSize * 0.3, center.dy);
        checkPath.lineTo(center.dx - iconSize * 0.1, center.dy + iconSize * 0.2);
        checkPath.lineTo(center.dx + iconSize * 0.3, center.dy - iconSize * 0.2);
        canvas.drawPath(checkPath, iconPaint);
        break;
        
      case AchievementType.weekStreak:
        // Draw calendar with stars
        final calendarRect = RRect.fromRectAndRadius(
          Rect.fromCenter(center: center, width: iconSize, height: iconSize * 0.8),
          Radius.circular(3),
        );
        canvas.drawRRect(calendarRect, iconPaint);
        break;
        
      case AchievementType.focusChampion:
        // Draw brain with timer
        canvas.drawCircle(center, iconSize * 0.4, iconPaint);
        break;
        
      case AchievementType.voiceCommander:
        // Draw microphone with waves
        canvas.drawRRect(
          RRect.fromRectAndRadius(
            Rect.fromCenter(center: center, width: iconSize * 0.4, height: iconSize * 0.6),
            Radius.circular(iconSize * 0.2),
          ),
          iconPaint,
        );
        break;
        
      case AchievementType.productivityGuru:
        // Draw rising graph
        final graphPath = Path();
        graphPath.moveTo(center.dx - iconSize * 0.3, center.dy + iconSize * 0.2);
        graphPath.lineTo(center.dx, center.dy);
        graphPath.lineTo(center.dx + iconSize * 0.3, center.dy - iconSize * 0.2);
        canvas.drawPath(graphPath, iconPaint);
        break;
    }
  }
  
  @override
  bool shouldRepaint(AchievementBadgePainter oldDelegate) {
    return oldDelegate.type != type ||
           oldDelegate.tier != tier ||
           oldDelegate.isUnlocked != isUnlocked;
  }
}

// Update the old painter references to use new MindFlow colors
class VoiceWavePainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = MindFlowGraphics.primaryBlue.withOpacity(0.8)
      ..strokeWidth = 3
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final path = Path();
    
    // Chaotic wave on the left
    path.moveTo(20, size.height * 0.5);
    for (int i = 0; i < 5; i++) {
      double x = 20 + (i * 20);
      double y = size.height * 0.5 + (i % 2 == 0 ? -30 : 30) * (1 - i * 0.1);
      path.lineTo(x, y);
    }
    
    // Transition to organized line
    path.lineTo(size.width * 0.7, size.height * 0.5);
    path.lineTo(size.width - 20, size.height * 0.5);
    
    canvas.drawPath(path, paint);
    
    // Add subtle task box at the end
    final boxPaint = Paint()
      ..color = MindFlowGraphics.calmGray.withOpacity(0.3)
      ..style = PaintingStyle.fill;
    
    canvas.drawRRect(
      RRect.fromRectAndRadius(
        Rect.fromLTWH(size.width - 40, size.height * 0.4, 30, 20),
        Radius.circular(4),
      ),
      boxPaint,
    );
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// Helper function for math
double cos(double angle) => math.cos(angle);
double sin(double angle) => math.sin(angle);
